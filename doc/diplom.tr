.so 2syktsu.tmac
.\"nr HI 3*\n[PI]
.ds M \(Fo
.ds U \(Fc
.ds DS "дата, подпись
.ds - \(em
.ds _ \(en
.ds FGCAPBG Рисунок
.ds FGCAPSM рис.
.ds FGNRSEP \(em
.char \[star] "\v'-0.2m'\(**\v'0.2m'"
.ds TOCFONTSIZE +0; +0; +0; +0
.
.
.TC
.U1 "ОПРЕДЕЛЕНИЯ, ОБОЗНАЧЕНИЯ И СОКРАЩЕНИЯ"
.PP
В настоящей работе применяются следующие сокращения и определения с соответсвующими значениями: 
.PP
HDL \(em hardware describe language;
.PP
RAM \(em random access memory;
.PP
Random access memory \(em вид памяти, в котором можно единовременно получить доступ к любой ячейке;
.PP
Read only memory \(em вид памяти, к которой возможен только доступ на чтение;  
.PP
RISC-архитектура\(em архитектура процессора, в которой быстродействие увеличивается за счёт упрощения инструкций, 
чтобы их декодирование было более простым, а время выполнения \(em  меньшим;  
.PP
RISK \(em reduced instruction set computer;
.PP
ROM \(em read only memory;
.PP
UART \(em universal asynchronous receiver-transmitter.
.PP
Universal asynchronous receiver-transmitter \(em  устройство, преобразующее передаваемые данные в последовательный вид так, 
чтобы было возможно передать их по одной физической цифровой линии другому аналогичному устройству.   
.PP
АЛУ \(em арифметико-логическое устройство;
.PP
Арифметико-логическое устройство \(em блок процессора, выполнений арифметические и логические преобрания над данными;
.PP
Архитектура ЦПУ \(em набор типов данных, операций и регистров, доступных для программирования;
.PP
АС \(em аппаратное средство;
.PP
Базовый алгоритм шифрования \(em блочный шифр, реализующий обратимое отображение блоков открытого текста в блоки шифртекста;
.PP
ВКР \(em выпускнаая квалификационная работа;
.PP
ЗИ \(em защита информации;
.PP
Интерфейс \(em совокупность средств, методов и правил взаимодействия между элементами системы;  
.PP
Ключ шифрования \(em изменяемый  параметр  в  виде  последовательности  символов, 
определяющий криптографическое преобразование;  
.PP
КМЗИ \(em криптографические методы ЗИ;
.PP
Контроллер \(em блок процессора, генерирующее сигналы управления трактом данных процессора;  
.PP
ЛЭ \(em логические элементы;
.PP
Микроархитектура ЦПУ \(em способ, которым данная архитектура реализована в процессоре;  
.PP
ПЛИС \(em программируемые логические интегральные схемы;
.PP
.PP
Потоковый шифратор \(em устройство, в котором каждый символ открытого текста преобразуется в символ шифрованного текста 
в зависимости не только от используемого ключа, но и от его расположения в потоке открытого текста, 
в котором нет необходимости в дополнении текста до определённой длины;
.PP
САПР \(em система автоматического проектирования;
.PP
Система автоматического проектирования \(em система. предназначенная для автоматизации процесса проектирования и разработки;  
.PP
Тракт данных \(em часть микроархитектуры, осуществляющая преобразования данных;  
.PP
ЦПУ \(em центральное процессорное устройство;
.PP
.
.
.
.U1 "ВВЕДЕНИЕ"
.PP
Постоянное развитие технологий приводит к повсеместному
применению электронных устройств и постоянному обмену информацией между ними. 
Утечка данной информации может послужить источником угроз приватности 
и даже общественной безопасности.
Важность передаваемой информации стимулирует массовое применение средств защиты.
Самым распространённым средством защиты передачи данных 
является криптографический метод.
Большинство систем используют широко распространённые, 
стандартизованные протокола передачи данных, 
однако иногда возникает необходимость обеспечить безопасность передачи данных,
циркулирующих в нестандартных системах, 
для которых не существует "шаблонных" готовых решений.
Разработка систем защиты для нестандартных решений "с нуля" может отнять много времени, сил, денег и других ресурсов.
Помимо того, криптографические методы защиты информации
(КМЗИ) хоть и повышают защищённость данных, однако,
требуют большого количества дополнительных вычислений,
нагружающих аппаратуру. 
Стандартные микропроцессорные устройства имеют общий, неспециализированный набор команд, использование которых снижает скорость обработки данных. 
.PP
В данных условиях было решено разработать вариант самостоятельного аппаратного средства (АС) защиты информации (ЗИ). 
К данному устройству предъявляются следующие требования:
.RS
.PI \(bu
Cпособность к интеграции с любыми цифровыми интерфейсами;
.PI \(bu
Возможность изменения структуры устройства на аппаратном уровне, 
адаптирования устройства к различным факторам;
.PI \(bu
Желательна возможность более быстрого изменения алгоритма работы устройства посредством его программирования.
.RE
.PP
Учитывая данные требования, возможным решением может стать разработка АС на основе 
программируемых логических интегральных схем (ПЛИС) посредством описания его на языке описания аппаратуры (HDL). 
Дабы была возможность программирования устройства, а так же для увеличения гибкости его применения, 
было решено выполнить данное устройство в виде процессорного ядра MIPS-подобной архитектуры  
с расширенным трактом данных для оптимизации криптографических вычислений.
.PP
Объектом исследования выпускной квалификационной работы (ВКР) является создание аппаратного средства шифрования данных, удовлетворяющего вышеописанным требованиям.
.PP
Предметом исследования ВКР является процесс создания микропроцессорного ядра и оптимизация его для реализации алгоритма шифрования на аппаратном уровне.
.PP
Целью ВКР является создание процессорного ядра с MIPS-подобной архитектурой и расширенным трактом данных, оптимизированным для реализации выбранного криптографического алгоритма.
.PP
\*BПостановка задачи\*P
.PP
Для достижения поставленной цели необходимо решить следующие задачи:
.RS
.PI \(bu
Изучить ПЛИС и HDL;
.PI \(bu
Разработать архитектуру процессорного ядра;
.PI \(bu
Выбрать алгоритм шифрования для реализации;
.PI \(bu
Разработать микроархитектуру процессорного ядра;
.PI \(bu
Произвести оптимизацию процессорного ядра;
.PI \(bu
Реализовать шифрование тестового канала передачи данных для демонстрации возможностей устройства.
.RE
.
.
.
.H1 "ИНСТРУМЕНТЫ РЕАЛИЗАЦИИ"
.
.H2 "ПЛИС"
.PP
На сегодняшний день при проектировании цифровых устройств никто не использует 
дискретные элементы. 
Данный подход трудозатратен, дорогостоящ и неэффективен.
Вместо этого применяют матрицы логических элементов.
.LQ fig:fpga
.PP
ПЛИС представляет собой матрицу конфигурируемых логических элементов (ЛЭ), 
которые также называются конфигурируемыми логическими блоками. 
Каждый ЛЭ можно сконфигурировать для выполнения
функций некoторой комбинационной или последовательной схемы.
На Рисунке \*(LT приведена обобщённая структура ПЛИС. 
ЛЭ окружены элементами ввода/вывода, 
которые предназначены для организации обмена информацией между FPGA и
прочими компонентами системы. 
Элементы ввода/вывода соединяют входы и выходы логических элементов с 
контактами корпуса микросхемы. 
Логические элементы могут быть соединены между собой
и с элементами ввода/вывода с помощью программируемых каналов трассировки[3].
.FG images/FPGA.eps fig:fpga "Пример структуры ПЛИС"
.PP
На сегодняшний день рынок ПЛИС в основном представлен двумя компаниями-производителями:
Xilinx и Altera. 
Обе компании зарекомендовали себя отличными производителями, 
в результате чего рынок поделён примерно пополам.
.
.
.H2 "HDL"
.PP
В 1990-е годы разработчики обнаружили, 
что их производительность труда резко возрастала, 
если они работали на более высоком уровне абстракции,
определяя только логическую функцию и предоставляя создание
оптимизированных логических элементов системе автоматического
проектирования и разработки (САПР). 
Для этой цели стали использовать языки описания аппаратуры или HDL. 
Два основных языка описания аппаратуры \(em Verilog и VHDL.
Verilog и VHDL построены на похожих принципах, 
но их синтаксис весьма различается.
В сравнении с Verilog VHDL является более громоздким и многословным.
Вдобавок, на сегодняшний день, наблюдается тенденция к преобладанию Verilog.
.PP
На обоих языках можно полностью описать любую электронную
систему.
Две основные цели HDL \(em логическая симуляция и синтез[2].
.PP
Симуляция предназанчена для снижения затрат на тестирование системы.
Тестирование системы в лаборатории весьма трудоёмко. 
Исследовать причины ошибок в лаборатории может быть очень сложно,
так как наблюдать можно только сигналы, подключенные к контактам чипа,
а то, что происходит внутри чипа, напрямую наблюдать невозможно.
Исправление ошибок уже после того, как система была выпущена,
может быть очень дорого. 
Например, исправление одной ошибки в новейших интегральных микросхемах
стоит больше миллиона долларов и занимать несколько месяцев.
.PP
Во время симуляции на входы модуля подаются некоторые воздействия и
проверяются выходы, чтобы убедиться, что модуль функционирует
корректно, так же, можно просмотреть состояние всех внутренних элементов.
С другой стороны, нужно учитывать, что данные значения являются дишь прогнозируемыми и могут несколько различаться с реальными.
Для приближения к реальности, производителями HDL и САПР придумана возможность задания дополнительных параметров симуляции.
При правильном задании всех параметров и правильном проектировании устройства, 
результаты симуляции практически всегда совпадают с реальными.
.PP
Логический синтез преобразует код на HDL в нетлист, описывающий
цифровую аппаратуру (т.е. логические элементы и соединяющие их
проводники). Логический синтезатор может выполнять оптимизацию
для сокращения количества необходимых элементов. Нетлист может
быть текстовым файлом или нарисован в виде схемы, чтобы было
легче визуализировать систему.
.PP
В конце концов, нетлист можно преобразовать в бинарную "прошивку" и
загрузить её на ПЛИС.
.H2 "Выбор метода реализации задач"
.PP
Основной задачей данной работы является создание микропроцессорного ядра посредством описания его на HDL, 
оптимизация его для криптографического алгоритма и демонстрация его возможностей посредством шифрования тестового канала передачи данных.
Инструментами для решения основной задачи на основании вышеизложенных фактов были выбраны 
язык описания аппаратуры Verilog и 
тестовая ПЛИС Xilinx Spartan-3AN FPGA Starter Kit Board.
Для демонстрации было решено реализовать шифрование данных, передаваемых по малопопулярному на сегодняшний день интерфейсу RS-232. 
.
.
.
.H1 "АРХИТЕКТУРА ПРОЦЕССОРНОГО ЯДРА"
.PP
В качестве основы для разрабатываемой архитектуры используется архитектура MIPS, а потому, используется понятие "MIPS-подобная архитектура".
Архитектура MIPS является простой reduced instruction set computer (RISC) архитектурой.
.PP
От архитектуры MIPS были унаследованы следующие основные особенности:
.RS
.PI \(bu
Форматы инструкций;
.PI \(bu
Режимы адресации;
.RE
.PP
Помимо того, были унаследованы основные команды и дополнены командами,
оптимизированными для реализации алгоритма ГОСТ Р 34.12 с размером блока 64 бита.
В следующих частях этой главы рассматриваются вышеописанные особенности разрабатываемой архитектуры.
.
.
.H2 "Типы инструкций"
.PP
В архитектуре MIPS в качестве компромисса между простотой и
универсальностью используются три формата инструкций: 
типа R, типа I и типа J.
Небольшое количество форматов обеспечивает определенное
единообразие между всеми тремя типами и, как следствие, 
более простую аппаратную реализацию. 
При этом разные форматы позволяют учитывать 
различные потребности инструкций, как, например, 
необходимость хранить большие константы внутри инструкций.
.
.H3 "Инструкции типа R"
.LQ fig:Rtype
.PP
Название типа R является сокращением от "Register-type" \(em регистрового типа. 
Инструкции типа R используют три регистра в качестве операндов: 
два регистра-источника и один регистр-назначение.
На Рисунке \*(LT показан машинный формат команды типа R. 32-битная
команда состоит из шести полей: \f(CWop, rs, rt, rd, shamt\fP и \f(CWfunct\fP.
Каждое поле состоит из пяти или шести бит[2].
.sp 0
.FG images/Rtype.eps fig:Rtype "Инструкция типа R"
.PP
Операция, выполняемая командой, закодирована двумя полями: 
полем \f(CWop\fP (также называемым \f(CWopcode\fP или
кодом операции) и полем \f(CWfunc\fP (также называемым функцией). 
У всех команд типа R поле \f(CWopcode\fP равно нулю. 
Операция, выполняемая этими командами, 
определяется исключительно полем \f(CWfunct\fP. 
Например, поля \f(CWopcode\fP и \f(CWfunct\fP у инструкции \f(CWadd\fP
равны 0 и 32 соответственно.
Аналогично, у команды \f(CWsub\fP поля \f(CWopcode\fP
и \f(CWfunct\fP равны 0 и 34.
.PP
Операнды закодированы тремя полями: \f(CWrs, rt\fP и \f(CWrd \fP. 
Поля содержат
номера регистров.
Пятое поле, \f(CWshamt\fP, является сокращением от shift amount
используется только для операций сдвига.
В таких командах двоичное значение, хранимое в 5-битном поле
\f(CWshamt\fP, задаёт величину сдвига. 
У всех остальных команд типа R поле  \f(CWshamt\fP равно 0.
.
.H3 "Инструкции типа I"
.PP
Название типа I является сокращением от immediate-type или 
непосредственного типа. 
Инструкции типа I используют в качестве операндов два регистра и 
один непосредственный операнд (константу).
.LQ fig:Itype
.PP
На Рисунке \*(LT показан формат машинной команды типа I. 32-битная
команда состоит из четырёх полей: \f(CWop, rs, rt\fP и \f(CWimm\fP. 
Первые три поля \f(CW(op, rs\fP и \f(CWrt)\fP аналогичны таким же полям в командах типа R. 
Поле \f(CWimm\fP (сокр. от immediate) содержит 16-битную константу.
16-битные константы перед использованием в операциях 
будут расширены до 32 бит посредством знакового расширения 
либо дополнения нулями[2].
.FG images/Itype.eps fig:Itype "Инструкция типа I"
.PP
Операция определяется исключительно полем \f(CWopcode\fP. 
Операнды заданы в трёх полях: 
\f(CWrs, rt \fPи \f(CWimm. \fPПоля \f(CWrs\fP и
imm всегда используются как операнды-источники. 
Поле \f(CWrt\fP в некоторых командах (например, \f(CWaddi\fP и \f(CWlw\fP) содержит номер регистра-назначения,
в других (например, \f(CWsw\fP) \(em номер регистра-источника.
.
.H3 "Инструкции типа J"
.LQ fig:Jtype
.PP
Название типа J является сокращением от английского слова jump \(em прыжок.
Этот формат используется только для инструкций безусловного перехода и ветвления.
Как и другие команды, команды типа J начинаются с 6-битного поля
кода операции  \f(CWopcode\fP.
Также, этот формат инструкций содержит 26-битный операнд \f(CWaddr\fP.
Константное значение \f(CWaddr\fP используется для указания адреса перехода[2].
.
.FG images/Jtype.eps fig:Jtype "Инструкция типа J"
.
.H2 "Режимы адресации"
.PP
В архитектуре MIPS используются пять режимов адресации:
регистровый, непосредственный, базовый, относительно счётчика команд
и псевдопрямой. Первые три режима (регистровый, непосредственный и базовый) 
определяют способы чтения и записи операндов. 
Последние два (режим адресации относительно счетчика команд и 
псевдопрямой режим) определяют способы записи счётчика команд[2].
.
.H3 "Регистровая адресация"
.PP
При регистровой адресации регистры используются для всех
операндов-источников и операндов-назначений 
(иными словами \(em для всех операндов и результата). 
Все инструкции типа R используют именно такой режим адресации[2].
.
.H3 "Непосредственная адресация"
.PP
При непосредственной адресации в качестве операндов наряду с
регистрами используют 16-битные константы (непосредственные операнды). 
Этот режим адресации используют некоторые инструкции типа I, 
такие как сложение с константой \f(CW(addi)\fP и загрузка константы в
старшие 16 бит регистра \f(CW(lui)\fP[2].
.
.H3 "Базовая адресация"
.PP
Инструкции для доступа в память, такие как загрузка слова \f(CW(lw)\fP и
сохранение слова \f(CW(sw)\fP, используют базовую адресацию. 
Эффективный адрес операнда в памяти вычисляется путём сложения базового 
адреса в регистре \f(CWrs\fP и 16-битного смещения с расширенным знаком,
являющегося непосредственным операндом[2].
.
.H3 "Адресация относительно счётчика команд"
.PP
Инструкции условного перехода, или ветвления, 
используют адресацию относительно счётчика команд 
для определения нового значения счётчика команд в том случае, 
если нужно осуществить переход.
Смещение со знаком прибавляется к счётчику команд (PC) для определения 
нового значения PC, поэтому тот адрес, куда будет осуществлен переход,
называют адресом относительно счётчика команд[2].
.
.H3 "Псевдопрямая адресация"
.PP
При прямой адресации адрес перехода задаётся внутри инструкции.
Инструкции безусловного перехода \f(CWj\fP и \f(CWjal\fP в идеале могли бы
использовать прямую адресацию для определения 32-битного
целевого адреса перехода, указывающего адрес инструкции, 
которая будет выполнена следующей.
К сожалению, в формате инструкций типа J нет достаточного
количества бит для того, чтобы задать полный 32-битный адрес перехода.
Шесть старших бит инструкции занимает код операции (поле \f(CWopcode)\fP, 
поэтому для адреса перехода остаётся только 26 бит.
К счастью, два младших бита адреса перехода всегда должны быть равны нулю,
потому что все инструкции выровнены по словам.
Следующие 26 бит адреса перехода берутся из поля \f(CWaddr \fPинструкции. 
Четыре старших бита адреса перехода берутся из 
четырёх старших бит значения \f(CW PC + 4\fP. 
Такой способ адресации называется псевдопрямым[2].
.
.
.H2 "Инструкции"
.EQ
delim off
.EN
.PP
При составлении итогового набора инструкций, основными целями являлись минималистичность, 
простота и максимальная применяемость.
Всего в конечном наборе инструкций присутствует 26 инструкций.
.PP
При описании инструкций используются следующие обозначения:
.RS
.PI \(bu
\f(CW[reg]\fP \(em содержимое регистра;
.PI \(bu 
\f(CWimm\fP \(em непосредственный операнд в инструкциях типа I;
.PI \(bu 
\f(CWaddr\fP \(em адрес в инструкциях типа J;
.PI \(bu 
\f(CWsignext\fP\(em непосредственный операнд после знакового расширения;
.PI \(bu 
\f(CWzeroext\fP\(em непосредственный операнд после расширения нулями;
.PI \(bu 
\f(CWBTA\fP\(em целевой адрес ветвления;
.PI \(bu 
\f(CWJTA\fP\(em целевой адрес перехода;
.PI \(bu 
\f(CWPC\fP\(em значение счётчика команда;
.PI \(bu 
\f(CWlabel\fP\(em текстовая метка для адреса инструкции;
.PI \(bu 
\f(CWaddr\fP\(em адрес в режиме адресации относительно счётчика команд;
.PI \(bu 
\f(CW[addr]\fP\(em содержимое памяти по адресу \f(CWaddr\fP.
.PI \(bu 
\f(CWKEY[n]\fP\(em значение n-го 32-битного поля ключа \f(CWKEY \fP.
.PI \(bu 
\f(CWSUB[$n]\fP\(em значение таблицы SUB для регистра \f(CW$n\fP.
.RE
.
.H3 "Арифметические"
.PP
В итоговой архитектуре представлены следующие арифметические инструкции:
.RS
.PI \(bu
\f(CWadd $rd, $rs, $rt\fP \(em инструкция сложения со знаковым расширением:
\f(CW [$rd] = [$rs] + [$rt]\fP;
.PI \(bu
\f(CWsub  $rd, $rs, $rt\fP \(em инструкция вычитания со знаковым расширением: 
\f(CW[$rd] = [$rs] - [$rt]\fP;
.PI \(bu
\f(CWaddu $rd, $rs, $rt\fP \(em инструкция сложения без расширения знака: \f(CW[$rd] = [$rs] + [$rt]\fP;
.PI \(bu
\f(CWsubu  $rd, $rs, $rt\fP \(em инструкция вычитания без расширения знака: \f(CW[$rd] = [$rs] - [$rt]\fP;
.PI \(bu
\f(CWaddi $rd, $rs, imm\fP \(em инструкция сложения с непосредственным операндом со знаковым расширением: \f(CW[$rd] = [$rs] + imm\fP;
.PI \(bu
\f(CWsubi  $rd, $rs, imm\fP \(em инструкция вычитания непосредственного операнда со знаковым расширением: \f(CW[$rd] = [$rs] - imm\fP;
.RE
.
.H3 "Логические"
.PP
В итоговой архитектуре представлены следующие логические инструкции:
.RS
.PI \(bu
\f(CWand $rd, $rs, $rt\fP \(em инструкция логического И: \f(CW[$rd] = [$rs] and [$rt]\fP;
.PI \(bu
\f(CWandi $rd, $rs, imm\fP \(em инструкция логического И с непосредственным операндом: \f(CW[$rd] = [$rs] and imm\fP;
.PI \(bu
\f(CWnand $rd, $rs, $rt\fP \(em инструкция логического НЕ И: \f(CW[$rd] = not ([$rs] and [$rt])\fP;
.PI \(bu
\f(CWor $rd, $rs, $rt\fP \(em инструкция логического ИЛИ: \f(CW[$rd] = [$rs] or [$rt]\fP;
.PI \(bu
\f(CWori $rd, $rs, imm\fP \(em инструкция логического ИЛИ с непосредственным операндом: \f(CW[$rd] = [$rs] or imm\fP;
.PI \(bu
\f(CWnor $rd, $rs, $rt\fP  \(em инструкция логического НЕ ИЛИ: \f(CW[$rd] = not ([$rs] or [$rt])\fP;
.PI \(bu
\f(CWxor $rd, $rs, $rt\fP \(em инструкция логического ИСКЛЮЧАЮЩЕГО ИЛИ: \f(CW[$rd] = [$rs] xor [$rt]\fP;
.PI \(bu
\f(CWslt $rd, $rs, $rt\fP \(em инструкция "установить, если меньше": \f(CW[$rd] = ([$rs] < [$rt])? 1 : 0\fP;
.PI \(bu
\f(CWslti $rd, $rs, imm\fP \(em инструкция "установить, если меньше непосредственного операнда": \0\0   \f(CW[$rd] = ([$rs] < imm)? 1 : 0\fP;
.PI \(bu
\f(CWsll $rd, $rs, shamt\fP \(em инструкция логического сдвига влево: \f(CW[$rd] = [$rs] << shamt\fP;
.PI \(bu
\f(CWsrl $rd, $rs, shamt\fP \(em инструкция логического сдвига вправо: \f(CW[$rd] = [$rs] >> shamt\fP;
.RE
.
.H3 "Переходы и ветвления"
.PP
В итоговой архитектуре представлены следующие инструкции перехода и ветвления:
.RS
.PI \(bu
\f(CWbeq $rs, $rt, label\fP \(em ветвление, если равно: \f(CW([$rd] = [$rs])? PC = BTA\fP;
.PI \(bu
\f(CWbne $rs, $rt, label\fP \(em ветвление, если не равно: 
.sp 0
\f(CW([$rd] != [$rs])? PC = BTA\fP;
.PI \(bu
\f(CWj label\fP \(em безусловный переход: \f(CWPC = JTA\fP;
.PI \(bu
\f(CWjal label\fP \(em безусловный переход с возвратом: \f(CWPC = JTA, $ra = PC + 4\fP;
.PI \(bu
\f(CWjr $rs\fP \(em безусловный переход по регистру: \f(CWPC = [$rs]\fP;
.RE
.
.H3 "Передача данных"
.PP
В итоговой архитектуре представлены следующие инструкции передачи данных:
.RS
.PI \(bu
\f(CWlw $rt, imm($rs)\fP \(em загрузка слова из памяти: \f(CW$rt = [addr]\fP;
.PI \(bu
\f(CWsw $rt, imm($rs)\fP \(em загрузка слова в память: \f(CW[addr] = [$rt]\fP;
.PI \(bu
\f(CWlui $rt, imm\fP \(em загрузка непосредственного операнда в верхние 16 бит регисра и дополнение 0 нижних: \f(CW$rt = {imm, 16'b0}\fP;
.RE
.
.H3 "Дополнительные инструкции для оптимизации криптоалгоритма"
.PP
В итоговую архитектуру были добавлены следующие инструкции для оптимизации криптографического алгоритма.
.RS
.PI \(bu
\f(CWslc $rd, $rs, shamt\fP \(em инструкция циклического сдвига влево: 
.sp 0
\f(CW[$rd] = {[$rs][(sizeof($rs) - shamt - 1) : 0], 
.sp 0
[$rs][sizeof($rs) - 1 : sizeof($rs) - shamt}\fP;
.PI \(bu
\f(CWsrc $rd, $rs, shamt\fP \(em инструкция циклического сдвига вправо: 
.sp 0
\f(CW[$rd] = {[$rs][(shamt - 1) : 0], [$rs][sizeof($rs) - 1 : shamt}\fP;
.PI \(bu
\f(CWkxor $rd, $rs, shamt\fP \(em инструкция ИСКЛЮЧАЮЩЕГО ИЛИ с ключом:
.sp 0
\f(CW$rd = $rs xor KEY[shamt];
.PI \(bu
\f(CWcs $rt, $rs\fP \(em инструкция подстановки из таблицы подстановок:
.sp 0
\f(CW$rs = SUB[$rs].
.RE
.
.EQ
delim on
.EN
.
.
.
.H1 "АЛГОРИТМ ШИФРОВАНИЯ"
.PP
В качестве алгоритма шифрования для реализации выбран алгоритм ГОСТ 34.12-2015 с длиной блока 64 бита или \*QМагма\*U.
Данный алгоритм представляет из себя простую сеть Фейстеля, состоящую из 32 раундов.
Так как для демонстрации было принято реализовать потоковый шифратор, 
было решено реализовать данный алгоритм в режиме режиме гаммирования с обратной связью по выходу.
Подробности работы данного алгоритма и режима рассмотрены ниже.
.
.
.H2 "ГОСТ 34.12-2015. Алгоритм \*QМагма\*U"
.
.H3 "Преобразования"
.PP
В начале блок входного текста разбивается на две половины.
Основная часть всех преобразований выполняется над половиной, 
содержащей младшие 32 бита.
.PP
Первым преобразованием является сложение с ключом по модулю 2\u\s-432\s0\d.
.PP
Затем, полученный 32-битный блок разбивается на блоки по 4 бита, 
каждый из которых используется в качестве индекса в одной из 8 таблиц подстановок.
Выходные значения конкатенируются и получается новый 32-битный блок.
В рамках ГОСТ 34.12-2015 данное преобразование названо $t$-прееобразование. 
.FG images/t_trans.eps fig:t_trans "Преобразование $t$"
Третьим преобразованием является циклический сдвиг 32-битного блока в сторону старших разрядов на 11 бит[10].
.LQ fig:gfunct
.PP
Вышеописанные преобразования в документе ГОСТ-а объединяюстя в преобразование $g$,
которая в итоге приобретает вид, изображённый на Рисунке \*(LT.
.FG images/gfunct.eps fig:gfunct "Преобразование $g$"
.PP
После $g$-преобразования младшие 32 бита складываются по модулю 2 со старшими.
Получившийся 32-битный блок поступает на место младших 32 бит итогового блока,
а младшие 32 бита исходного \(em на место старших 32 бит итогового блока.
.PP
Вышеописанные преобразования в документе ГОСТ-а объединяются в преобразование $G$, равное одному раунду. 
Такой раунд повторяется 31 раз. 
В последнем этапе выход $f$-преобразования поступает на место старших 32-бит итогового блока,
а младшие 32 бита выхода предпоследнего этапа \(em на место младших 32 итогового.
.LQ fig:fullbaseencr
.PP
Полностью схема преобразований показана на Рисунке \*(LT.
.FG images/fullencr.eps fig:fullbaseencr "Полная схема преобразований"
.bp
.
.H3 "Выработка раундовых ключей"
.PP
Для генерации подключей исходный 256-битный ключ разбивается на восемь 32-битных блоков: $K sub 1 - K sub 8$:
.EQ
K sub 1 = k sub {255} || - ||k sub {224};
.EN

.EQ
K sub 2 = k sub {223} || - || k sub {192};
.EN

.EQ
K sub 3 = k sub {191} || - || k sub {160};
.EN

.EQ
K sub 4 = k sub {159} || - || k sub {128};
.EN

.EQ
K sub 5 = k sub {127} || - || k sub {96};
.EN

.EQ
K sub 6 = k sub {95} || - || k sub {64};
.EN

.EQ
K sub 7 = k sub {63} || - || k sub {32};
.EN

.EQ
K sub 8 = k sub {31} || - || k sub {0};
.EN
Ключи $K sub 9 - K sub {24}$ являются циклическим повторением ключей 
$K sub 1 - K sub 8$. 
Ключи $K sub {25} - K sub {32}$ являются ключами $K sub 8 - K sub 1$.
.
.H3 "Шифрование и расшифрование"
.PP
В итоге, шифрование одного 64-битного блока данных имеет следующий вид:
.EQ
E sub {K sub 1 - K sub {32}} (a) = G sup * [K sub 32 ] G[K sub 31 ] - G[K sub 1 ] (a sub 1, a sub 0 ),
.EN
.EQ
где \0 a = a sub 1 || a sub 0
.EN
.PP
Расшифрование отличается только порядком применения ключей:
.EQ
D sub {K sub 1 - K sub {32}} (a) = G sup * [K sub 1 ] G[K sub 2 ] - G[K sub 32 ] (a sub 1, a sub 0 ),
.EN
.EQ
где \0 a = a sub 1 || a sub 0
.EN
.
.
.H2 "Режим гаммирования с обратной связью по выходу"
.
.
.H3 "Общие положения"
.PP
Режим имеет следующие основные параметры:
.RS
.PI 
$s$ \(em размер вырабатываемой гаммы шифра;
.PI 
$n$ \(em размер блока базового алгоритма шифрования;
.PI 
$m = z \[md] n$ \(em размер регистра сдвига;
.PI 
$IV$ \(em синхропосылка.
.RE
.PP
Зашифрование  в  режиме  гаммирования  с  обратной  связью  по  выходу  
заключается в по компонентном сложении открытого текста с гаммой шифра,
которая вырабатывается  блоками  длины $s$.
При  вычислении  очередного  блока  гаммы выполняется  зашифрование 
$n$ разрядов регистра  сдвига с  большими  номерами базовым  алгоритмом блочного шифрования. 
Затем заполнение регистра сдвигается  на $n$ бит в сторону разрядов с большими номерами, 
при этом в разряды с меньшими номерами записывается полученный   выход   базового алгоритма блочногошифрования. 
Блок гаммы вычисляется путём усечения выхода базового алгоритма блочного шифрования. 
.PP
При использовании режима гаммирования с обратной связью по выходу не 
накладывается ограничений на длину входного блока открытого текста, 
а потому на его основе возможно построить потоковый шифратор.
.
.H3 "Зашифрование"
.PP
Открытый текст $P$ представляется в виде $P = P sub 1 ||P sub 2 ||...||P sub q,$
Блоки шифртекста вычисляются по следующему правилу:
.EQ
R sub 1 = IV,
.EN
.
.EQ
left { lpile {
( Y sub i = e sub k ( MSB sub n ( R sub i ) )
above
C sub i = P sub i ~ \[c+] ~  T sub s (Y sub i ),
above 
R sub {i+1} = LSB sub {m-n} ( R sub i ) || Y sub i,
}
rpile {
i = 1, ~ 2,..,q-1,
}
.EN
.
.EQ
Y sub q = e sub k ( MSB sub n ( R sub q ) )
.EN
.
.EQ
C sub q = P sub q ~ \[c+] ~  T sub r (Y sub q ),
.EN
.PP
Результирующий шифртекст имеет вид:
.EQ
C = C sub 1 ||C sub 2 ||...||C sub q .
.EN
.LQ fig:OFB
.PP
Зашифрование в режиме гаммирования с обратной связью по выходу
проиллюстрировано на Рисунке \*(LT.
.FG images/OFB.eps fig:OFB "Схема зашифрования в режиме гаммирования с обратной связью по выходу"
.H3 "Расшифрование"
.PP
Расшифрование абсолютно идентично шифрованию, за исключением того, 
что с вырабатываемой гаммой складывается не открытый текст, а шифртекст.
Данная особенность делает шифратор и дешифратор абсолютно идентичными.
.
.
.
.H1 "РЕАЛИЗАЦИЯ"
.PP
В данной главе описываются разработанное ядро, 
способ его оптимизации для реализации выбранного алгоритма и 
оснащение его интерфейсами для шифрования выбранного тракта передачи данных 
в качестве презентации его возможностей.
.
.
.H2 "Создание процессорного ядра"
.PP
Компьютерная архитектура определяется набором 
команд и архитектурным состоянием. 
Архитектурное состояние процессора MIPS определяется содержимым 
счётчика команд (program counter) и 32 видимых программисту регистра,
поэтому любой процессор, реализующий MIPS-подобную архитектуру, 
вне зависимости от его микроархитектуры обязан иметь счётчик команд и 
ровно 32 регистра.
Зная текущее архитектурное состояние, процессор точно знает, 
какую операцию и над какими данными надо выполнить для получения нового
архитектурного состояния.
.LQ fig:cpu
.PP
Рассмотрим структуру, показанную на Рисунке \*(LT и модуль верхнего уровня для разработанного процессорного ядра.
.FG images/datatr.eps fig:cpu "Общая схема ядра"
.bp
.PP
В файле cpu.v описана общая структура ядра.
.KS
.sp 0.5v
.in \n[PI]u
.nf
.vs -4p
.ta T 4m
.CW
module cpu
(
	input wire	clk_in,
	input wire	reset,

	input wire	rx_m,
	output wire	tx_m,
	input wire	rx_fem,
	output wire	tx_fem,

	output wire	led0,
	output wire	led1,
	output wire	led2,
	output wire	led3,
	output wire	led4,
	output wire	led5,
	output wire	led6,
	output wire	led7
	);

	wire [31:0]	instr, pc_val, mem_addr, 
	mem_write, mem_read, ram_out;
	wire [5:0]	op_c, funct;
	wire		zero, argB_c, we_c, wd_c, io_ram_c, 
	io_uart_fem_c, io_uart_m_c, clk;
	wire [1:0]	dest_reg_c, ext_c, io_read_c;
	wire [2:0]	pc_next_c, result_c;
	wire [3:0]	us, alu_c; 
	wire [7:0]	leds, uart_fem_r, uart_m_r;
	wire [31:0]	bus, tmr_ctrl;
	wire		counter, tmr_overflow; 
	wire [15:0]	tmr_cntr;

	reg 		counter_reg = 1'b1;

	always @ (posedge clk_in)
		counter_reg <= counter;
	
	assign counter = counter_reg + 1'b1;
	assign clk = counter;

	contr		contr_u ( .op_c(op_c), .funct(funct), 
	.zero(zero), .argB_c(argB_c), .dest_reg_c(dest_reg_c), 
	.result_c(result_c),.we_c(we_c), .ext_c(ext_c), .wd_c(wd_c), 
	.sh_d_c(sh_d_c), .pc_next_c(pc_next_c), .alu_c(alu_c));

	datapath	datapath_u ( .clk(clk), .reset(reset), 
	.instr(instr), .pc_val(pc_val), .mem_addr(mem_addr), 
	.mem_write(mem_write), .mem_read(mem_read), .op_c(op_c), 
	.funct(funct), .zero(zero), .argB_c(argB_c), 
	.dest_reg_c(dest_reg_c), .result_c(result_c), .we_c(we_c), 
	.ext_c(ext_c),.wd_c(wd_c),  .sh_d_c(sh_d_c), 
	.pc_next_c(pc_next_c), .alu_c(alu_c), .us(us), 
	.tmr_ctrl(tmr_ctrl), .tmr_cntr(tmr_cntr), 
	.tmr_overflow(tmr_overflow), .leds(leds), .bus(bus));

	instr_mem	instr_mem (.addr(pc_val[10:0]), .data(instr));

	timer		tmr (.clk(clk), .reset(~tmr_ctrl[31]), 
	.scale(tmr_ctrl[30:16]), .period(tmr_ctrl[15:0]), 
	.cntr(tmr_cntr), .overflow(tmr_overflow));

	io_contr	io_c (.addr(mem_addr), .op_c(op_c), 
	.io_ram_c(io_ram_c), .io_uart_fem_c(io_uart_fem_c),
	.io_uart_m_c(io_uart_m_c), .io_read_c(io_read_c));

	ram		data_mem (.clk(clk), .we(io_ram_c), 
	.addr(mem_addr[11:0]), .d_in(mem_write), .d_out(ram_out));

	uart		uart_fem (.clk(clk), .reset(reset), 
	.rd_uart(io_read_c[0]), .wr_uart(io_uart_fem_c), .rx(rx_fem), 
	.w_data(mem_write[7:0]), .tx_full(us[1]), .rx_empty(us[0]), 
	.tx(tx_fem), .r_data(uart_fem_r));

	uart		uart_m (.clk(clk), .reset(reset), 
	.rd_uart(io_read_c[1]), .wr_uart(io_uart_m_c), .rx(rx_m), 
	.w_data(mem_write[7:0]), .tx_full(us[3]), .rx_empty(us[2]), 
	.tx(tx_m), .r_data(uart_m_r));

	mux3to1		mux_io_read (.in0(ram_out), 
	.in1({24'b0, uart_fem_r}), .in2({24'b0, uart_m_r}), 
	.ctrl(io_read_c), .out(mem_read));
	
	assign {led0, led1, led2, led3, led4, led5, led6, led7} = leds; 

endmodule
.sp 0.5v
.PL
.ce 1
\*B Файл CPU.v\*P
.sp 1v
.KE
.PP
В структуре итогового процессорного ядра можно выделить 3 основных модуля:
.RS
.PI 1.
Регистровый файл;
.PI 2.
Арифметико-логическое устройство;
.PI 3.
Контроллер.
.RE
.PP
В рамках данной части будут рассмотрены эти три модуля.
Файлы описания остальной части ядра приведены в приложении.
.PP
Файл reg_file.v содержит описание регистрового файла, 
хранящего все 32 видимых регистра.
.
.EQ
delim off
.EN
.
.sp 0.5v
.in \n[PI]u
.nf
.ta T 4m
.vs -4p
.CW
`include "./include/registers.v"

module reg_file(
	input wire		clk,
	input wire		we,//for write enable

	input wire [4:0]	ra1,//
	input wire [4:0]	ra2,//for read  addresses
	input wire [4:0]	wa,//for write address

	
	output wire [31:0]	rd1,// for read data
	output wire [31:0]	rd2,//
	input wire [31:0]	wd,//for write data
	
	input wire [3:0]	us,//for uart state
	input wire [15:0]	tmr_cntr,//for timer counter
	output wire [31:0]	tmr_ctrl,//for timer controll

	output wire [7:0]	leds
);

	reg [31:0] rf [31:0];
	
	initial 
		begin
		$readmemh("reg_init.data", rf, 0, 31);
		end
		
	always @(posedge clk)
		if (we)
			rf[wa] <= wd;

	assign rd1 = (ra1 == `US)? {28'b0, us} : 
	((ra1 == `TMR)? {16'b0, tmr_cntr} : rf[ra1]);
	assign rd2 = (ra2 == `US)? {28'b0, us} : 
	((ra1 == `TMR)? {16'b0, tmr_cntr} : rf[ra2]);

	assign tmr_ctrl = rf[`TCON];
	
	assign leds = rf [`V0][7:0];

endmodule
.sp 0.5v
.PL
.ce 1
\*B Файл reg_file.v\*P
.sp 1v
.
.EQ
delim on
.EN
.
.PP
Регистровый файл выполнен в виде блока RAM.
На вход поступают 3 адреса \(em два адреса 
регистров-источников операндов (\f(CWrd1, rd2\fP),
значения которых подаются на выходы \f(CWrd1, rd2\fP и 
один адрес регистра-назначения результата (\f(CWwa\fP), 
которому присваивается значение, поданое на вход \f(CWwd\fP, 
при условии, что был послан управляющий сигнал \f(CWwe\fP. 
Помимо того, в регистровый файл отображаются состояния периферийных устройств.
Данная особенность будет рассмотрена подробнее позже.
.PP
Файл alu.v содержит описание арифметико-логического устройства (АЛУ).
.sp 0.5v
.in \n[PI]u
.nf
.ta T 4m
.vs -4p
.CW
module alu(
	input wire [3:0]	mode,
	input wire [31:0]	A,
	input wire [31:0]	B,
	output reg [31:0]	C,
	output reg		zero
    );
	 
localparam //functions
	 //logical
	 and_f = 4'b0000,
	 or_f = 4'b0001,
	 xor_f = 4'b0010,
	 nor_f = 4'b0011,
	 slt_f = 4'b0100,
	 nand_f = 4'b0101,
	 
	 //arithmetic
	 add_f = 4'b1000,
	 subtr_f = 4'b1001;
	 
	 always @ *
	 begin
	 zero = 0;
		case(mode)
		and_f:
			C = A & B;
			
		nand_f:
			C = ~(A & B);
			
		or_f:
			C = A | B;	
			
		xor_f:
			C = A ^ B;
			
		nor_f:
			C = ~(A | B);

		slt_f:
			C = (A < B) ? 32'h00000001 : 32'h00000000;

		subtr_f:
			C = A - B;
			
		add_f:
			C = A + B;
			
		default:
			C = A;
			
		endcase
		
		if (C == 0)
				zero = 1'b1;
	 end

endmodule
.sp 0.5v
.PL
.ce 1
\*B Файл alu.v\*P
.sp 1v
.PP
На входы \f(CWA\fP и \f(CWB\fP подаются значения операндов, 
на вход \f(CWmode\fP  \(em код выполняемой инструкции, 
результат подаётся на выход \f(CWC\fP.
Стоит так же отметить наличие флага \f(CWzero\fP, 
выставляемого при равенстве результата нулю.
.PP
Файл contr.v содержит описание контроллера.
.sp 0.5v
.in \n[PI]u
.nf
.ta T 4m
.vs -4p
.CW
`include "./include/funct_codes.v"
module contr(
	input wire		zero,
	input wire [5:0]	op_c, 
	input wire [5:0]	funct,

	output wire		argB_c,
	output wire [1:0]	dest_reg_c,
	output wire		we_c,
	output wire [1:0]	ext_c,
	output wire		wd_c,
	output wire		sh_d_c,
	output wire [2:0]	pc_next_c,
	output wire [2:0]	result_c,
	output wire [3:0]	alu_c
	);
	
	wire [2:0] 	aluop;
	wire 		jr_c;
	
	maindec		main_dec(.funct(funct), .op_c(op_c), 
	.argB_c(argB_c), .dest_reg_c(dest_reg_c), 
	.we_c(we_c), .result_c(result_c), .beq(beq), 
	.bne(bne), .j_c(j_c), .jr_c(jr_c), .ext_c(ext_c), 
	.wd_c(wd_c), .sh_d_c(sh_d_c), .aluop(aluop));

	aludec		alu_dec(.funct(funct), 
	.aluop(aluop), .alu_c(alu_c) );
	
	assign branch_c =(~zero & bne) | (zero & beq);
	assign pc_next_c = {jr_c, j_c, branch_c};

endmodule
.sp 0.5v
.PL
.ce 1
\*B Файл contr.v\*P
.sp 1.5v
.PP
Контроллер разделён на две части: основной декодер и декодер АЛУ.
Основной декодер преобразует кода операции и функции в управляющие сигналы.
Декодер АЛУ преобразует код функции и сигнал \f(CWaluop\fP, 
поступающий с основного декодера в управляющие сигналы АЛУ.
.
.
.H2 "Оптимизация ядра для реализации криптографического алгоритма"
.PP
Основной упор в процессе оптимизации был сделан на максимальное снижение 
взаимодействия с памятью на время выполнения алгоритма шифрования.
Причиной этому является то, 
что хоть архитектура процессора и является гарвардской, 
а сам процессор однотактным,
взаимодействие с памятью всё равно является трудозатратным и ресурсоёмким процессом.
.H3 "Выработка раундовых ключей"
.PP
Во-первых, в тракт данных был добавлен модуль, 
реализующий генерацию раундовых ключей.
Описание данного модуля содержит файл \f(CWrk_gen.v\fP (raund key generator).
.sp 0.5v
.in \n[PI]u
.nf
.ta T 4m
.vs -4p
.CW
module rk_gen 
(
	input wire [4:0]	raund,
	output wire [31:0]	raundkey
);
	reg [31:0] key [2:0];
	wire [2:0] keynum;

	initial
	begin
		key[0] = 32'hffeeddcc;
		key[1] = 32'hbbaa9988;
		key[2] = 32'h77665544;
		key[3] = 32'h33221100;
		key[4] = 32'hf0f1f2f3;
		key[5] = 32'hf4f5f6f7;
		key[6] = 32'hf8f9fafb;
		key[7] = 32'hfcfdfeff;
	end

	assign keynum = (raund[4:3] == 2'b11)? raund[2:0] : ~raund[2:0];

	assign raundkey = key[keynum];

endmodule
.sp 0.5v
.PL
.ce 1
\*B Файл rk_gen.v\*P
.sp 1.5v

.PP
Номер раунда поступает на вход \f(CWraund\fP. 
256-битный ключ реализован в виде блока ROM. 
Для вычисления номера подключа из номера раунда, 
использовалось одно замеченное свойство: 
если начать нумерацию раундов не с 1, а с 0, 
то номером ключей для первых 24 (0-23) раундов является значение последних 3 бит номера раунда.
Для последних же 8 раундов (24-31) для получения номера раундового ключа, 
достаточно произвести инвертацию последних 3 бит.
Данная операция описана в следующей строке:
.PP
\f(CWassign keynum = (raund[4:3] == 2'b11)? raund[2:0] : ~raund[2:0];\fP 
.PP
Выход данного модуля через мультиплексор подключён ко входу А АЛУ.
На вход В подаётся значение 32-битного блока.
АЛУ производит операцию сложения данных значений по модулю 2.
Таким образом, полностью реализовано сложение с раундовым ключом за 1 рабочий такт процессора.
.H3 "Реализация таблицы подстановок"
.PP
Во-вторых, был добавлен модуль, реализующий таблицу подстановок на аппаратном уровне.
Описание данного модуля содержит файл \f(CWsubst.v \fP(look up table).
.sp 0.5v
.in \n[PI]u
.nf
.ta T 4m
.vs -4p
.CW
module subst 
(
	input wire [31:0]	in,
	output wire [31:0]	out
);
	reg  [3:0] sub0 [15:0];
	reg  [3:0] sub1 [15:0];
	reg  [3:0] sub2 [15:0];
	reg  [3:0] sub3 [15:0];
	reg  [3:0] sub4 [15:0];
	reg  [3:0] sub5 [15:0];
	reg  [3:0] sub6 [15:0];
	reg  [3:0] sub7 [15:0];

	wire [3:0] out0, out1, out2, out3, out4, out5, out6, out7; 

	initial
	begin
	sub0[0] = 4'hc; sub0[1] = 4'h4; sub0[2] = 4'h6; sub0[3] = 4'h2;
	sub0[4] = 4'ha; sub0[5] = 4'h5; sub0[6] = 4'hb; sub0[7] = 4'h9;
	sub0[8] = 4'he; sub0[9] = 4'h8; sub0[10] = 4'hd; sub0[11] = 4'h7; 
	sub0[12]= 4'h0; sub0[13] = 4'h3; sub0[14] = 4'hf; sub0[15] = 4'h1; 

	sub1[0] = 4'h6; sub1[1] = 4'h8; sub1[2] = 4'h2; sub1[3] = 4'h3;
	sub1[4] = 4'h9; sub1[5] = 4'ha; sub1[6] = 4'h5; sub1[7] = 4'hc;
	sub1[8] = 4'h1; sub1[9] = 4'he; sub1[10] = 4'h4; sub1[11] = 4'h7; 
	sub1[12]= 4'hb; sub1[13] = 4'hd; sub1[14] = 4'h0; sub1[15] = 4'hf; 

	sub2[0] = 4'hb; sub2[1] = 4'h3; sub2[2] = 4'h5; sub2[3] = 4'h8;
	sub2[4] = 4'h2; sub2[5] = 4'hf; sub2[6] = 4'ha; sub2[7] = 4'hd;
	sub2[8] = 4'he; sub2[9] = 4'h1; sub2[10] = 4'h7; sub2[11] = 4'h4; 
	sub2[12]= 4'hc; sub2[13] = 4'h9; sub2[14] = 4'h6; sub2[15] = 4'h0; 
	
	sub3[0] = 4'hc; sub3[1] = 4'h8; sub3[2] = 4'h2; sub3[3] = 4'h1;
	sub3[4] = 4'hd; sub3[5] = 4'h4; sub3[6] = 4'hf; sub3[7] = 4'h6;
	sub3[8] = 4'h7; sub3[9] = 4'h0; sub3[10] = 4'ha; sub3[11] = 4'h5; 
	sub3[12]= 4'h3; sub3[13] = 4'he; sub3[14] = 4'h9; sub3[15] = 4'hb; 
	
	sub4[0] = 4'h7; sub4[1] = 4'hf; sub4[2] = 4'h5; sub4[3] = 4'ha;
	sub4[4] = 4'h8; sub4[5] = 4'h1; sub4[6] = 4'h6; sub4[7] = 4'hd;
	sub4[8] = 4'h0; sub4[9] = 4'h9; sub4[10] = 4'h3; sub4[11] = 4'he; 
	sub4[12]= 4'hb; sub4[13] = 4'h4; sub4[14] = 4'h2; sub4[15] = 4'hc; 
	
	sub5[0] = 4'h5; sub5[1] = 4'hd; sub5[2] = 4'hf; sub5[3] = 4'h6;
	sub5[4] = 4'h9; sub5[5] = 4'hc; sub5[6] = 4'hc; sub5[7] = 4'ha;
	sub5[8] = 4'hb; sub5[9] = 4'h7; sub5[10] = 4'h8; sub5[11] = 4'h1; 
	sub5[12]= 4'h4; sub5[13] = 4'h3; sub5[14] = 4'he; sub5[15] = 4'h0; 
	
	sub6[0] = 4'h8; sub6[1] = 4'he; sub6[2] = 4'h2; sub6[3] = 4'h5;
	sub6[4] = 4'h6; sub6[5] = 4'h9; sub6[6] = 4'h1; sub6[7] = 4'hc;
	sub6[8] = 4'hf; sub6[9] = 4'h4; sub6[10] = 4'hb; sub6[11] = 4'h0; 
	sub6[12]= 4'hd; sub6[13] = 4'ha; sub6[14] = 4'h3; sub6[15] = 4'h7; 
	
	sub7[0] = 4'h1; sub7[1] = 4'h7; sub7[2] = 4'he; sub7[3] = 4'hd;
	sub7[4] = 4'h0; sub7[5] = 4'h5; sub7[6] = 4'h8; sub7[7] = 4'h3;
	sub7[8] = 4'h4; sub7[9] = 4'hf; sub7[10] = 4'ha; sub7[11] = 4'h6; 
	sub7[12]= 4'h9; sub7[13] = 4'hc; sub7[14] = 4'hb; sub7[15] = 4'h2; 
	end

	assign out0 = sub0[in[31:28]];
	assign out1 = sub1[in[27:24]];
	assign out2 = sub2[in[23:20]];
	assign out3 = sub3[in[19:16]];
	assign out4 = sub4[in[15:12]];
	assign out5 = sub5[in[11:8]];
	assign out6 = sub6[in[7:4]];
	assign out7 = sub7[in[3:0]];

	assign out = {out0, out1, out2, out3, out4, out5, out6, out7};
endmodule
.sp 0.5v
.PL
.ce 1
\*B Файл subst.v\*P
.sp 1.5v
.PP
Сама таблица реализована в виде 8 блоков ROM \f(CW(sub0 - sub7)\fP.
На вход \f(CWin\fP подаётся значение блока, для которого производится операция замены.
Данное значение разбивается на 4-битные блоки, 
которые в дальнейшем используются в качестве адреса соответствующего им блока ROM.
Полученные значения от каждого блока конкатенируются и подаются на выход \f(CWout\fP. 
.H3 "Аппаратная реализация сдвиговых операций"
.PP
В третьих, было расширено устройство сдвига посредством добавления в него возможности циклического сдвига.
Данный вид сдвига не входит в базовую архитектуру  MIPS-процессоа.
Описание данного модуля содержит файл \f(CWshifter.v \fP.
.sp 0.5v
.in \n[PI]u
.nf
.ta T 4m
.vs -4p
.CW
module shifter (
	input wire [1:0]	sh_c,
	input wire [4:0]	shamt,
	input wire [31:0]	in,

	output wire[31:0]	out
	);
	
	wire [31:0] ls0, rs0, ls1, rs1, ls2, rs2, ls3, rs3, ls4, rs4; 
	
	assign rs0 = shamt[0] ? {in[0], in[31:1]} : in;
	assign ls0 = shamt[0] ? {in[30:1], in[31]} : in;

	assign rs1 = shamt[1] ? {rs0[1:0], rs0[31:2]} : rs0;
	assign ls1 = shamt[1] ? {ls0[29:0], ls0[31:30]} : ls0;

	assign rs2 = shamt[2] ? {rs1[3:0], rs1[31:4]} : rs1;
	assign ls2 = shamt[2] ? {ls1[27:0], ls1[31:28]} : ls1;

	assign rs3 = shamt[3] ? {rs2[7:0], rs2[31:8]} : rs2;
	assign ls3 = shamt[3] ? {ls2[23:0], ls2[31:24]} : ls2;

	assign src = shamt[4] ? {rs3[15:0], rs3[31:16]} : rs3;
	assign slc = shamt[4] ? {ls3[15:0], ls3[31:16]} : ls3;

	assign out = sh_c[1] ? (sh_c[0]? slc : src) : 
	(sh_c[0]? (in << shamt) : (in >> shamt));

endmodule
.sp 0.5v
.PL
.ce 1
\*B Файл shifter.v\*P
.sp 1.5v
.PP
В данном модуле циклический сдвиг реализован в поэтапном виде, 
т.е. каждый последующий этап реализует больший сдвиг, чем предыдущий.
Данная схема наиболее оптимальна при сдвиге большого количества бит.
.H3 "Итог"
.PP
Таким образом, доля инструкций обмена данными с памятью во время выполнения основного алгоритма шифрования сведена к минимуму.
Полная раелизация одного раунда основного алгоритма МАГМА занимает всего рабочих тактов процессора.
В главе, посвящённой разработке ассемблера, приведён код реализации алгоритма шифрования на специально созданном языке ассемблера.
.
.
.
.H2 "Оснащение процессора периферийными интерфейсами"
.PP
В итоговый процессор была включена поддержка двух периферийных интерфейсов: RS-232 DB9 и DE9.
Передача данных поверх этого интерфейса происходит по протоколу UART.
Конечное устройство производит шифрование и дешифрование данных, передаваемых по данным интерфейсам.
Данные интерфейсы были выбраны по причине их изначального присутствия на тестовой плате, 
относительной простоты их реализации, а так же потому,
что ни данные интерфейсы, а тем более, 
ни шифраторы данных интерфейсов не пользуются популярностью.
.PP
Хотя компания Xilinx и распространяет готовый интерфейс для своих плат,
было решено создать свою реализацию для достижения переносимости кода на платы других производителей
и интеграции с остальной микроархитектурой устройства.
.PP
Описание модуля верхнего уровня интерфейса содержится в файле \f(CWuart.v\fP.
Описания для разъёмов DB9 и DE9 абсолютно идентичны, а потому, 
нет смысла их дублировать.
.sp 0.5v
.in \n[PI]u
.nf
.ta T 4m
.vs -4p
.CW
 module uart 
 	#(
	parameter	
	DBIT = 		8,
	SB_TICK = 	16,
	DVSR = 		81,
	DVSR_BIT = 	7,
	FIFO_W =	2
	)
	(
	input wire		clk, reset,
	input wire		rd_uart, wr_uart, rx,
	input wire [7:0]	w_data,
	output wire		tx_full, rx_empty, tx,
	output wire [7:0]	r_data
	);

	wire 		tick, rx_done_tick, tx_donr_tick;
	wire 		tx_empty, tx_not_empty;
	wire [7:0] 	tx_fifo_out, rx_data_out;

	tick_gen	#(.M(DVSR), .N(DVSR_BIT)) tg (.clk(clk), 
	.reset(reset), .tick(tick));
	
	uart_rx		#(.DBIT(DBIT), .SB_TICK(SB_TICK)) 
	receiver (.clk(clk), .reset(reset), .rx(rx), .s_tick(tick), 
	.rx_done_tick(rx_done_tick), .dout(rx_data_out) );

	fifo_r		#(.B(DBIT), .W(FIFO_W)) 
	fifo_rx (.clk(clk), .reset(reset), .rd(rd_uart), 
	.wr(rx_done_tick), .w_data(rx_data_out), 
	.empty(rx_empty), .r_data(r_data));

	fifo_t		#(.B(DBIT), .W(FIFO_W)) 
	fifo_tx (.clk(clk), .reset(reset), .rd(tx_done_tick), 
	.wr(wr_uart), .w_data(w_data), .empty(tx_empty), 
	.full(tx_full), .r_data(tx_fifo_out));

	uart_tx		#(.DBIT(DBIT), .SB_TICK(SB_TICK)) 
	transmitter (.clk(clk), .reset(reset), .tx_start(tx_not_empty), 
	.s_tick(tick), .din(tx_fifo_out), 
	.tx_done_tick(tx_done_tick), .tx(tx) );

	assign tx_not_empty = ~tx_empty;

endmodule 	
.sp 0.5v
.PL
.ce 1
\*B Файл uart.v\*P
.sp 1.5v
.PP
Интерфейс состоит из конфигурируемого генератора тактового сигнала \f(CWtick_gen\fP, приёмника \f(CWuart_rx\fP, 
передатчика \f(CWuart_tx\fP и соответствующих FIFO-регистров \f(CWfifo_r\fP и \f(CWfifo_t\fP.
.EQ
delim off
.EN
.PP
Оба интерфейса связаны с регистром \f(CW$us\fP (uart state) в памяти.
Данный регистр содержит информацию о наличии принятых данных в регистре приёмника и
заполненности регистра передатчика.
В случае переполнения регистра приёмника, происходит соответствующее прерывание.
.
.
.H2 "Реализация программируемости устройства"
.PP
Последней желаемой характеристикой устройства явлеятся его программируемость.
В данной работе программируемость реализована несколько нестандартным методом.
Причины тому описаны ниже.
.PP
Во-первых, созданное процессорное ядро имеет гарвардскую архитектуру, что означает, 
что память команд и память данных физически разделены друг от друга, 
а память команд не изменяется в процессе работы устройства.
.PP
Во-вторых, устройство реализовано на основе ПЛИС, что значит, 
что его структуру можно изменить в любой момент.
.PP
В результате, память команд в данном случае можно реализовать в виде ROM-памяти.
Программируемость же означает реконфигурацию памяти команд в соответствии с неким программным кодом 
во время реконфигурации всей ПЛИС.
Первым преимуществом данного подхода является простота его реализации.
Вторым преимуществом является то, что при синтезе нетлиста происходит оптимизация тракта данных синтезатором,
который отбрасывает незадействованную часть логики. 
Так, например при реализации шифратора, в конечном нетлисте не будет присутствовать таймер, 
описание которого, однако, присутствует в составе проекта.
.PP
Для программирования устройства выбран язык ассемблера MIPS.
Для преобразования языка ассемблера в коды инструкций, 
был написан скрипт на языке AWK.
Программные файлы данного преобразователя находятся в каталоге \f(CWasm\fP.
Для создания более простого интерфейса преобразователя был написан shell-скрипт под названием \f(CWasm.sh\fP.
Память программ описана в файле \f(CWinstr_mem.v\fP. 
.sp 0.5v
.KS
.in \n[PI]u
.nf
.ta T 4m
.vs -4p
.CW
`include "./include/registers.v"
`include "./include/funct_codes.v"

module instr_mem (
	input wire [10:0] addr,
	output wire [31:0] data
	);
	
	reg [31:0] mem [511:0];

	initial
		begin
		$readmemh("instr.data", mem, 0, 511);
		end

	assign data = mem[addr[10:2]];

endmodule
.sp 0.5v
.PL
.ce 1
\*B Файл instr_mem.v\*P
.sp 1.5v
.KE
.PP
Директива \f(CW$readmemh("instr.data", mem, 0, 511)\fP 
инициализирует память команд содержимым файла \f(CWinstr.data\fP.
Подразумевается, что последний содержит вывод преобразователя.
.PP
В случае шифратора, файл ассемблерного кода выглядит следующим образом:
.sp 0.5v
.in \n[PI]u
.nf
.ta T 4m
.vs -4p
.CW
	ori $s0, $s0, 31

	lui $t1, 0xfedc
	ori $t1, $t1, 0xba98

	lui $t0, 0x7654
	ori $t0, $t0, 0x3210

	lui $t3, 0xfedc
	ori $t3, $t3, 0xba98

	lui $t2, 0x7654
	ori $t2, $t2, 0x3210

init_male_encryption:
	andi $t4, $t4, 0x0
	
init_male_raund:
	ori $t5, $t0, 0x0000
	ckx $t0, $t4, $t0	
	cs $t0, $t0
	slc $t0, $t0, 11
	xor $t0, $t0, $t1
	ori $t1, $t5, 0x0000
	addi $t4, $t4, 0x0001
	bne $t4, $s0, init_male_raund

	ori $t5, $t0, 0x0000
	ckx $t0, $t4, $t0	
	cs $t0, $t0
	slc $t0, $t0, 11
	xor $t1, $t0, $t1
	ori $t0, $t5, 0x0000

init_female_encryption:	
	andi $t4, $t4, 0x0
	
init_female_raund:
	ori $t6, $t2, 0x0000
	ckx $t2, $t4, $t2	
	cs $t2, $t2
	slc $t2, $t2, 11
	xor $t2, $t2, $t3
	ori $t3, $t6, 0x0000
	addi $t4, $t4, 0x0001
	bne $t4, $s0, init_female_raund

	ori $t6, $t2, 0x0000
	ckx $t2, $t4, $t2	
	cs $t2, $t2
	slc $t2, $t2, 11
	xor $t3, $t2, $t3
	ori $t2, $t6, 0x0000

	j uart_load


male_encryption:	
	andi $t4, $t4, 0x0
	
male_raund:
	ori $t5, $t0, 0x0000
	ckx $t0, $t4, $t0	
	cs $t0, $t0
	slc $t0, $t0, 11
	xor $t0, $t0, $t1
	ori $t1, $t5, 0x0000
	addi $t4, $t4, 0x0001
	bne $t4, $s0, male_raund

	ori $t5, $t0, 0x0000
	ckx $t0, $t4, $t0	
	cs $t0, $t0
	slc $t0, $t0, 11
	xor $t1, $t0, $t1
	ori $t0, $t5, 0x0000

	j uart_load

female_encryption:	
	andi $t4, $t4, 0x0
	
female_raund:
	ori $t6, $t2, 0x0000
	ckx $t2, $t4, $t2	
	cs $t2, $t2
	slc $t2, $t2, 11
	xor $t2, $t2, $t3
	ori $t3, $t6, 0x0000
	addi $t4, $t4, 0x0001
	bne $t4, $s0, female_raund

	ori $t6, $t2, 0x0000
	ckx $t2, $t4, $t2	
	cs $t2, $t2
	slc $t2, $t2, 11
	xor $t3, $t2, $t3
	ori $t2, $t6, 0x0000

	j uart_load

uart_load:
	andi $t7, $us, 0x0004
	beq $t7, $0, male_received

	andi $t7, $us, 0x0001
	beq $t7, $0, female_received
	
	j uart_load

male_received:
	lw $t8, 0xfff8($0)
	xor $t8, $t0, $t8
	sw $t8, 0xfffc($0)
	j male_encryption

female_received:
	lw $t8, 0xfffc($0)
	xor $t8, $t2, $t8
	sw $t8, 0xfff8($0)
	j female_encryption
.sp 0.5v
.PL
.ce 1
\*B Файл cipher.asm\*P
.sp 1.5v
.PP
Параметр z режима работы шифра выбран равным единице,
параметр n \*- восьми (см. стр. 16 гл. 2).
В начале происходит инициализация \(em в сдвиговые регистры загружается синхропосылка и шифруется стандартным алгоритмом шифрования.
Затем осуществляется безусловный переход к метке \f(CW uart_load\fP. 
Из регистра $us извлекается информация о состоянии UART-контроллеров.
Если какой-либо из них не пуст,
то из него загружается полученный байт, 
складывается по модулю 2 с соответствующим сдвиговым регистром и сохраняется в буфер другого контроллера.
Затем происходит переход к стандартному алгоритму шифрования соответствующего регистра.
Для обоих сдвиговых регистров код стандартного алгоритма шифрования дублирован, 
а не реализован в виде отдельной функции. 
Это сделано для достижения дополнительной оптимизации.
.
.
.H2 "Характеристики итогового устройства"
.PP
Общие характеристики конечного устройства приведены в таблице.
.sp .5
\h'8.3c'Таблица 1 \(em Характеристики итогового устройства
.TS
tab(;) expand allbox;
c c 
l.
Характеристика;Значание 
Тактовая частота;25 МГц (при реализации на Spartan3AN)
Тактов на инструкцию;1
Разраядность;32 бита
Алгоритм шифрования;ГОСТ 34.12 с длиной блока 64 бита "МАГМА"
Таймер;16-битный, конфигурируемый 
Интерфейсы;LED x8, RS-232-DE9, RS232-DB9 
.TE
.PP
На основании вышеизложенных характеристик, можно точно измерить возможные скорости шифрования устройства:
.EQ
V sub ш = f / N sub и = 25000000 / 302 = 82781 \0 (Блок/сек)
.EN
.EQ
1 \0 бит <= B <= 64 \0 бита
.EN
.EQ
82781 \0 бит <= V sub ш * B <= 662251 \0 байт
.EN
.EQ
f - тактовая частота;
.EN
.EQ
N sub и - количество \0 инструкци \0 для \0 шифрования \0 одного \0 блока;
.EN
.EQ
B - размер \0 одного \0 блока;
.EN
.EQ
V sub ш - количество \0 шифруемых \0 в \0 секунду \0 блоков.
.EN
.PP
Дальнейшие изменения скорости работы могут быть связаны со скоростью работы интерфейса.
.
.
.H2 "Сравнение с возможными альтернативами устройства"
.PP
Естественно, как уже отмечалось ранее, у получивщегося устройства имеется ряд альтернатив,
среди которых можно выделить три основные группы:
.nr step 0 1
.PP
\n+[step].
Готовые криптоконтроллеры;
.PP
\n+[step].
Готовые контроллеры, содержащие криптосопроцессоры;
.PP
\n+[step].
Софт-процессоры с оптимизированными модулями для криптографических вычислений.
.PP
Каждая группа обладает рядом преимуществ и недостатков по сравнению с остальными.
.PP
Действительно близкими по смыслу и функционалу к представленному устройству являются представители третьей группы.
Существует ряд свободно распространяемых софт-процессоров, например, CryptoBlaze компании Xilinx.
Данные устройства почти всегда являются оптимизированными для плат определённого производителя, 
что является как их положительной, так и отрицательной стороной, ведь при переносе на другие платы, чаще всего возникают проблемы.
.PP
Первые две группы являют собой готовые аппаратные блоки.
Разделение на две группы производится толко по типам внутренней структуры, 
которая рассматриваться подробнее не будет, а потому в дальнейшем они будут объединены в одну.
Представители данной группы обладают значительно большей производительностью по сравнению с софт-процессорами, 
так как являются готовыми отптимизированными аппаратными блоками, 
а софт-процессоры \(em по факту, лишь совокупностью запрограммированных ячеек.
Так, например, контроллеры STM32F4xx компании STMicroelectronics способны работать на частоте до 168МГц, 
используя 32-битный тракт данных, что в результате приводит к скорости шифрования в разы большей, чем у получившегося устройства.
Однако, софт-процессоры имеют гораздо болшую гибкость по сравнению с готовыми аппаратными блоками.
Так, например, при необходимости реализовать алгоритм \*QМАГМА\*U на базе контроллера из серии STM32F4xx,
пришлось бы реализовывать его на программном уровне, что заняло бы не меньше времени, 
чем описание оптимизированного модуля на Verilog или VHDL для софт процессора, 
а работало бы, возможно, несколько хуже и с затратой несколько больших ресурсов.
Наконец, намного большие проблемы возникли бы, при необходимости реализовать шифрацию данных,
передаваемых через специфичный канал передачи.
.PP
Учитывая, что достижение максимальной гибкости и переносимости является основной целью данной работы,
можно сделать вывод о том, что полученное устройство является достойной альтернативой существующим решениям стоящей проблемы.
.
.
.U1 "ЗАКЛЮЧЕНИЕ"
.PP
В ходе ВКР был решён ряд задач.
.PP
Была изучена необходимая для решения дальнейших задач теоретическая база.
.PP
Была составлена архитектура процессорного ядра, 
содержащая все необходимые средства для решения поставленной цели.
.PP
В качестве основного алгоритма шифрования был выбран алгоритм ГОСТ 32.12-2015 с длиной блока 64 бита или \*QМАГМА\*U.
Для реализации на его основе шифратора, использовался режим работы гаммирования с обратной связью по выходу.
.PP
Былa разработана и описана микроархитектура процессорного ядра, 
реализующего составленную MIPS-подобную архитектуру на языке Verilog.
.PP
Для оптимизации выполнения выбранного криптоалгоритма разработанным микропроцессором, 
был расширен его тракт данных посредством введения в него модулей, реализующих следующие операции, присущие выбранному алгоритму:
.RS
.PI 1.
Выработка раундовых ключей;
.PI 2.
Операция подстановок;
.PI 3.
Циклический сдвиг.
.RE
.PP
Был реализован и интегрирован с основным ядром интерфейс RS-232 и 
реализован потоковый шифратор протокола UART, используемого для передачи данных по этому интерфейсу для демонстрации возможностей полученного устройства.
.PP
Таким образом, было спроектировано и описано на языке Verilog процессорное ядро с трактом данных, 
оптимизированным для криптографических вычислений алгоритма ГОСТ 34.12-2015 с длиной блока 64 бита \*QМАГМА\*U.
На основе данного ядра было создано устройство потокового шифрования данных.
Устройство реализовано и протестировано на плате Xilinx Spartan 3-AN.
Устройство удовлетворяет всем предъявленным требованиям, 
оно показало неплохие результаты работы, сравнимые с аналогами.
Явными его преимуществами являются простота адаптации к любым ситуациям и открытость и переносимость описания микроархитектуры.
.
.
.
.U1 "СПИСОК ИСПОЛЬЗОВАННЫХ ЛИТЕРАТУРЫ И ИСТОЧНИКОВ"
.nr step 0 1
.PP
\n+[step].
CryptoBlaze: 8-Bit Security Microcontrolleri. \(em v1.0. \(em XILINX, 2003. \(em
9 c.
.PP
\n+[step]. David M. Harris and Sarah L. Harris. Digital Design and Computer Architecture. \(em 1-е изд. \(em Boston:Morgan Kaufman, 2007. \(em 570 c.
.PP
\n+[step]. P. Pal Chaudhuri. Computer organisation and design. \(em 3-е изд. \(em Delhi:PHI Learning, 2014. \(em 897 c.
.PP
\n+[step].
Pong P. Chu. FPGA prototyping by Verilog examples Xilinx Spartan-3 Version. \(em New Jersey:John Wiley & Sons, 2008. \(em 488 c.
.PP
\n+[step].
Spartan-3A/3AN FPGA Starter Kit Board User Guidei. \(em v. 1.1. \(em XILINX, 2008. \(em 140 c.
.PP
\n+[step]. The Institute of Electrical and Electronics Engineers. IEEE 1364-2001 IEEE Standard Verilog Hardware Description Language. \(em 
3 Park Avenue, New York, NY 10016-5997, USA:The Institute of Electrical and Electronics Engineers, 2001i. \(em 778 c.
.PP
\n+[step]. The Institute of Electrical and Electronics Engineers. 
IEEE Std 1076, 2000 Edition IEEE Standard VHDL Language Reference Manual. \(em
3 Park Avenue, New York, NY 10016-5997, USA:
The Institute of Electrical and Electronics Engineers, 2000. \(em 299 c.
.PP
\n+[step]. Cамоделов А. Криптография в отдельном блоке: криптографический сопроцессор семейства STM32F4xx: 
[ Электронный ресурс ] //
Официальный сайт компании "Компэл":
URL: http://www.compel.ru/lib/ne/2012/6/4-kriptografiya-v-otdelnom-bloke-kriptograficheskiy-so\%protsessor-semeystva-stm32f4xx. (дата обращения 03.12.2016).
.PP
\n+[step]. Федеральное агентство по техническому регулированию и метрологии. ГОСТ Р 34.13-2015 Информационная технология КРИПТОГРАФИЧЕСКАЯ ЗАЩИТА ИНФОРМАЦИИ Режимы работы блочных шифровi. \(em М.:Стандартинформ,2015. \(em 42 с.
.PP
\n+[step]. Федеральное агентство по техническому регулированию и метрологии. ГОСТ Р 34.12-2015 Информационная технология КРИПТОГРАФИЧЕСКАЯ ЗАЩИТА ИНФОРМАЦИИ Блочные шифры. \(em М.:Стандартинформ,2015. \(em 25 с.
.
.U1 "ПРИЛОЖЕНИЯ"
.
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \s+2\fB Приложение А\fP\s0 
.sp 0v
\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \fB СПИСОК ФАЙЛОВ НА CD-ДИСКЕ\fP
.
.nr step 0 1
.
.PP
\0\n+[step].\ Spartan-3A/3AN FPGA Starter Kit Board User Guide.
.PP
\0\n+[step].\ Файл  adder.v;
.PP
\0\n+[step].\ Файл aludec.v;
.PP
\0\n+[step].\ Файл alu.v;
.PP
\0\n+[step].\ Файл contr.v;
.PP
\0\n+[step].\ Файл cpu.v;
.PP
\0\n+[step].\ Файл datapath.v;
.PP
\0\n+[step].\ Файл instr_mem.v;
.PP
\0\n+[step].\ Файл io_contr.v;
.PP
\n+[step].\ Файл kxor.v;
.PP
\n+[step].\ Файл maindec.v;
.PP
\n+[step].\ Файл mux2to1.v;
.PP
\n+[step].\ Файл mux3to1.v;
.PP
\n+[step].\ Файл mux4to1.v;
.PP
\n+[step].\ Файл PC.v;
.PP
\n+[step].\ Файл pc_val_mux.v;
.PP
\n+[step].\ Файл ram.v;
.PP
\n+[step].\ Файл reg_file.v;
.PP
\n+[step].\ Файл registers.v;
.PP
\n+[step].\ Файл rk_gen.v;
.PP
\n+[step].\ Файл func_codes.v;
.PP
\n+[step].\ Файл shifter.v;
.PP
\n+[step].\ Файл sign_ext.v;
.PP
\n+[step].\ Файл sll2.v;
.PP
\n+[step].\ Файл subst.v;
.PP
\n+[step].\ Файл timer.v;
.PP
\n+[step].\ Файл asm.sh;
.PP
\n+[step].\ Файл final.awk;
.PP
\n+[step].\ Файл init.awk;
.PP
\n+[step].\ Файл oplist.awk;
.PP
\n+[step].\ Файл cipher.asm.
